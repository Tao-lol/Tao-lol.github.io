---
title: 为什么我使用了索引，查询还是慢？
tags:
  - 程序设计
categories:
  - 编程
date: 2020-01-20 16:57:57
---

> https://www.cnblogs.com/jackyfei/p/12122767.html

<!--more-->

&emsp;&emsp;经常有同学问我，我的一个 SQL 语句使用了索引，为什么还是会进入到慢查询之中呢？今天我们就从这个问题开始来聊一聊索引和慢查询。  
&emsp;&emsp;另外插入一个题外话，个人认为团队要合理的使用 ORM，可以参考我的另外一篇 [ORM 的权衡和抉择](https://www.cnblogs.com/jackyfei/p/orm.html)。合理利用的是 ORM 在面向对象和写操作方面的优势，避免联合查询上可能产生的坑(当然如果你的 Linq 查询能力很强另当别论)，因为 ORM 屏蔽了太多的 DB 底层的知识内容，对程序员不是件好事，对性能有极致追求，但是 ORM 理解不透彻的团队更加要谨慎。

# 案例剖析
&emsp;&emsp;言归正传，为了实验，我创建了如下表：
```sql
CREATE TABLE `T`(
`id` int(11) NOT NULL,
`a` int(11) DEFAUT NULL,
PRIMARY KEY(`id`),
KEY `a`(`a`)
) ENGINE=InnoDB; 
```
&emsp;&emsp;该表有三个字段，其中用 id 是主键索引，a 是普通索引。

&emsp;&emsp;首先 SQL 判断一个语句是不是慢查询语句，用的是语句的**执行时间**。他把语句执行时间跟`long_query_time`这个系统参数作比较，如果语句执行时间比它还大，就会把这个语句记录到慢查询日志里面，这个参数的默认值是 10 秒。当然在生产上，我们不会设置这么大，一般会设置 1 秒，对于一些比较敏感的业务，可能会设置一个比 1 秒还小的值。  
&emsp;&emsp;语句执行过程中有没有用到表的索引，可以通过 explain 一个语句的输出结果来看 KEY 的值不是 *NULL* 。

&emsp;&emsp;我们看下`explain select * from t;`的 KEY 结果是 *NULL* 。
![ ](127185-20191230235703940-953153691.png)

&emsp;&emsp;`explain select * from t where id=2;`的 KEY 结果是 *PRIMARY* ，就是我们常说的使用了主键索引。
![ ](127185-20191230235848320-1277891431.png)

&emsp;&emsp;`explain select a from t;`的 KEY 结果是 a，表示使用了 a 这个索引。
![ ](127185-20191231000005395-549365412.png)

&emsp;&emsp;虽然后两个查询的 KEY 都不是 *NULL* ，但是最后一个实际上扫描了整个索引树 a。  
&emsp;&emsp;假设这个表的数据量有 100 万行，图二的语句还是可以执行很快，但是图三就肯定很慢了。如果是更极端的情况，比如，这个数据库上 CPU 压力非常的高，那么可能第2个语句的执行时间也会超过`long_query_time`，会进入到慢查询日志里面。

&emsp;&emsp;所以我们可以得出一个结论：**是否使用索引和是否进入慢查询之间并没有必然的联系**。使用索引只是表示了一个 SQL 语句的执行过程，而是否进入到慢查询是由它的执行时间决定的，而这个执行时间，可能会受各种外部因素的影响。换句话来说，使用了索引你的语句可能依然会很慢。

# 全索引扫描的不足
&emsp;&emsp;那如果我们在更深层次的看这个问题，其实他还潜藏了一个问题需要澄清，就是什么叫做使用了索引。  
&emsp;&emsp;我们都知道，InnoDB 是索引组织表，所有的数据都是存储在索引树上面的。比如上面的表 t，这个表包含了两个索引，一个主键索引和一个普通索引。在 InnoDB 里，数据是放在主键索引里的。如图所示：
![ ](127185-20191231001858399-761094562.png)

&emsp;&emsp;可以看到数据都放在主键索引上，如果从逻辑上说，所有的 InnoDB 表上的查询，都至少用了一个索引，所以现在我问你一个问题，如果你执行`select from t where id>0`，你觉得这个语句有用上索引吗？
![ ](127185-20191231002153612-543561900.png)

&emsp;&emsp;我们看上面这个语句的 explain 的输出结果显示的是 *PRIMARY* 。其实从数据上你是知道的，这个语句一定是做了全面扫描。但是优化器认为，这个语句的执行过程中，需要根据主键索引，定位到第 1 个满足 ID > 0 的值，也算用到了索引。

&emsp;&emsp;所以即使 explain 的结果里写的 **KEY 不是 *NULL* ，实际上也可能是全表扫描**的，因此 InnoDB 里面只有一种情况叫做没有使用索引，那就是从主键索引的最左边的叶节点开始，向右扫描整个索引树。

也就是说，没有使用索引并不是一个准确的描述。
* 你可以用**全表扫描**来表示一个查询遍历了**整个主键索引树**；
* 也可以用**全索引扫描**，来说明像`select a from t;`这样的查询，他扫描了**整个普通索引树**；
* 而`select * from t where id=2`这样的语句，才是我们平时说的使用了索引。他表示的意思是，我们使用了索引的快速搜索功能，并且有效的减少了扫描行数。

# 索引的过滤性要足够好
&emsp;&emsp;根据以上解剖，我们知道全索引扫描会让查询变慢，接下来就要来谈谈索引的过滤性。  
&emsp;&emsp;假设你现在维护了一个表，这个表记录了中国 14 亿人的基本信息，现在要查出所有年龄在 10 ~ 15 岁之间的姓名和基本信息，那么你的语句会这么写，`select * from t_people where age between 10 and 15`。  
&emsp;&emsp;你一看这个语句一定要在 age 字段上开始建立索引了，否则就是个全面扫描，但是你会发现，在你建立索引以后，这个语句还是执行慢，因为满足这个条件的数据可能有超过 1 亿行。  
&emsp;&emsp;我们来看看建立索引以后，这个表的组织结构图：
![ ](127185-20191231004118284-1830591492.png)

这个语句的执行流程是这样的：
1. 从索引上用树搜索，取到第 1 个 age 等于 10 的记录，得到它的主键 id 的值，根据 id 的值去主键索引取整行的信息，作为结果集的一部分返回；
2. 在索引 age 上向右扫描，取下一个 id 的值，到主键索引上取整行信息，作为结果集的一部分返回；
3. 重复上面的步骤，直到碰到第 1 个 age 大于 15 的记录。

&emsp;&emsp;你看这个语句，虽然他用了索引，但是他扫描超过了 1 亿行。所以你现在知道了，当我们在讨论有没有使用索引的时候，其实我们关心的是**扫描行数**。

&emsp;&emsp;**对于一个大表，不止要有索引，索引的过滤性还要足够好。**  
&emsp;&emsp;像刚才这个例子的 age，它的过滤性就不够好，在设计表结构的时候，我们要让所有的过滤性足够好，也就是区分度足够高。

# 回表的代价
&emsp;&emsp;那么过滤性好了，是不是表示查询的扫描行数就一定少呢？  
&emsp;&emsp;我们再来看一个例子：  
&emsp;&emsp;如果你的执行语句是`select * from t_people where name='张三' and age=8`  
&emsp;&emsp;t_people 表上有一个索引是姓名和年龄的联合索引，那这个联合索引的过滤性应该不错，可以在联合索引上快速找到第 1 个姓名是张三，并且年龄是 8 的小朋友，当然这样的小朋友应该不多，因此向右扫描的行数很少，查询效率就很高。  
&emsp;&emsp;但是查询的过滤性和索引的过滤性可不一定是一样的，如果现在你的需求是查出所有名字的第 1 个字是张，并且年龄是 8 岁的所有小朋友，你的语句会怎么写呢？  
&emsp;&emsp;很显然你会这么写：`select * from t_people where name like '张%' and age=8;`  
&emsp;&emsp;在 MySQL 5.5 和之前的版本中，这个语句的执行流程是这样的：
![ ](127185-20191231005952670-1472639774.png)

1. 首先从联合索引上找到第 1 个年龄字段是张开头的记录，取出主键 id，然后到主键索引树上，根据 id 取出整行的值；
2. 判断年龄字段是否等于 8，如果是就作为结果集的一行返回，如果不是就丢弃。
3. 在联合索引上向右遍历，并重复做回表和判断的逻辑，直到碰到联合索引树上名字的第 1 个字不是张的记录为止。

&emsp;&emsp;我们把根据 id 到主键索引上查找整行数据这个动作，称为**回表**。你可以看到这个执行过程里面，最耗费时间的步骤就是回表，假设全国名字第 1 个字是张的人有 8000 万，那么这个过程就要回表 8000 万次，在定位第一行记录的时候，只能使用索引和联合索引的最左前缀，最称为**最左前缀原则**。  
&emsp;&emsp;你可以看到这个执行过程，它的回表次数特别多，性能不够好，有没有优化的方法呢？  
&emsp;&emsp;在 MySQL 5.6 版本，引入了 index condition pushdown 的优化。我们来看看这个优化的执行流程：
![ ](127185-20191231010949787-983058366.png)

1. 首先从联合索引树上，找到第 1 个年龄字段是张开头的记录，判断这个索引记录里面，年龄的值是不是 8，如果是就回表，取出整行数据，作为结果集的一部分返回，如果不是就丢弃；
2. 在联合索引树上，向右遍历，并判断年龄字段后，根据需要做回表，直到碰到联合索引树上名字的第 1 个字不是张的记录为止。

&emsp;&emsp;这个过程跟上面的差别，是在遍历联合索引的过程中，将年龄等于 8 的条件下推到所有遍历的过程中，减少了回表的次数，假设全国名字第 1 个字是张的人里面，有 100 万个是 8 岁的小朋友，那么这个查询过程中在联合索引里要遍历 8000 万次，而回表只需要 100 万次。

# 虚拟列
&emsp;&emsp;可以看到这个优化的效果还是很不错的，但是这个优化还是没有绕开最左前缀原则的限制，因此在联合索引你还是要扫描 8000 万行，那有没有更进一步的优化方法呢？  
&emsp;&emsp;我们可以考虑把名字的第一个字和 age 来做一个联合索引。这里可以使用 MySQL 5.7 引入的**虚拟列**来实现。对应的修改表结构的 SQL 语句：
```sql
alter table t_people add name_first varchar(2) generated (left(name,1)),add index(name_first,age);
```

&emsp;&emsp;我们来看这个 SQL 语句的执行效果：
```sql
CREATE TABLE `t_people`(
`id` int(11) DEFAULT NULL,
`name` varchar(20) DEFAUT NULL,
`name_first` varchar(2) GENERATED ALWAYS AS (left(`name`,1)) VIRTUAL,KEY `name_first`(`name_first`,'age')
) ENGINE=InnoDB DEFAULT CHARSET=utf8; 
```

&emsp;&emsp;首先他在 people 上创建一个字段叫 name_first 的虚拟列，然后给 name_first 和 age 上创建一个联合索引，并且，让这个虚拟列的值总是等于 name 字段的前两个字节，虚拟列在插入数据的时候不能指定值，在更新的时候也不能主动修改，它的值会根据定义自动生成，在 name 字段修改的时候也会自动修改。  
&emsp;&emsp;有了这个新的联合索引，我们在找名字的第 1 个字是张，并且年龄为 8 的小朋友的时候，这个 SQL 语句就可以这么写：`select * from t_people where name_first='张' and age=8`。  
&emsp;&emsp;这样这个语句的执行过程，就只需要扫描联合索引的 100 万行，并回表 100 万次，这个优化的本质是我们创建了一个更紧凑的索引，来加速了查询的过程。

# 总结
&emsp;&emsp;本文给你介绍了索引的基本结构和一些查询优化的基本思路，你现在知道了，使用索引的语句也有可能是慢查询，我们的查询优化的过程，往往就是减少扫描行数的过程。

慢查询归纳起来大概有这么几种情况：
* 全表扫描
* 全索引扫描
* 索引过滤性不好
* 频繁回表的开销

# 思考
&emsp;&emsp;假设业务要求的就是要统计年龄在 10 - 15 岁的 14 亿人的数量，不能增加过滤因子，那该怎么办？(`select * from t_people where age between 10 and 15`)  
&emsp;&emsp;假设该统计必须是 OLTP，实时展示统计数据，又该怎么解决？
