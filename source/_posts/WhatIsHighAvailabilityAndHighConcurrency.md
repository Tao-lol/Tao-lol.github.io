---
title: 什么是 高可用 和 高并发
tags:
  - 程序设计
categories:
  - 编程
date: 2020-01-20 17:03:50
---

> 高可用：https://mp.weixin.qq.com/s/p0LsxT-JUS7zYg23M7nupQ  
> 高并发：https://mp.weixin.qq.com/s/bEkd2lcuK59Gpncuvyj1Ww  

<!--more-->

# 高可用
## 一、什么是高可用
&emsp;&emsp;**高可用** HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。  
&emsp;&emsp;假设系统一直能够提供服务，我们说系统的可用性是 100% 。如果系统每运行 100 个时间单位，会有 1 个时间单位无法提供服务，我们说系统的可用性是 99% 。  
&emsp;&emsp;很多公司的高可用目标是 4 个 9，也就是 99.99% ，这就意味着，系统的年停机时间为 8.76 个小时。  
&emsp;&emsp;百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过 www.baidu.com 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下了“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度 HA 最高的褒奖。

## 二、如何保障系统的高可用
&emsp;&emsp;我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他 backup 能够顶上。  
&emsp;&emsp;保证系统高可用，架构设计的**核心准则**是：**冗余**。  
&emsp;&emsp;有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“**自动故障转移**”来实现系统的高可用。

&emsp;&emsp;接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。

## 三、常见的互联网分层架构
![ ](1.webp)

常见互联网分布式架构如上，分为：  
（1）**客户端层**：典型调用方是浏览器 browser 或者手机应用 APP；  
（2）**反向代理层**：系统入口，反向代理；  
（3）**站点应用层**：实现核心应用逻辑，返回 html 或者 json；  
（4）**服务层**：如果实现了服务化，就有这一层；  
（5）**数据-缓存层**：缓存加速访问存储；  
（6）**数据-数据库层**：数据库固化数据存储；

整个系统的高可用，又是通过每一层的**冗余+自动故障转移**来综合实现的。

## 四、分层高可用架构实践
### 【客户端层 -> 反向代理层】的高可用
![ ](2.webp)
&emsp;&emsp;【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以 nginx 为例：有两台 nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是 keepalived 存活探测，相同 virtual IP 提供服务。

![ ](3.webp)
&emsp;&emsp;自动故障转移：当 nginx 挂了的时候，keepalived 能够探测到，会自动的进行故障转移，将流量自动迁移到 shadow-nginx，由于使用的是相同的 virtual IP，这个切换过程对调用方是透明的。

### 【反向代理层 -> 站点层】的高可用
![ ](4.webp)
&emsp;&emsp;【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是 nginx，`nginx.conf`里能够配置多个 web 后端，并且 nginx 能够探测到多个后端的存活性。

![ ](5.webp)
&emsp;&emsp;自动故障转移：当 web-server 挂了的时候，nginx 能够探测到，会自动的进行故障转移，将流量自动迁移到其他的 web-server，整个过程由 nginx 自动完成，对调用方是透明的。

### 【站点层 -> 服务层】的高可用
![ ](6.webp)
&emsp;&emsp;【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。

![ ](7.webp)
&emsp;&emsp;自动故障转移：当 service 挂了的时候，service-connection-pool 能够探测到，会自动的进行故障转移，将流量自动迁移到其他的 service，整个过程由连接池自动完成，对调用方是透明的（所以说 RPC-client 中的服务连接池是很重要的基础组件）。

### 【服务层 -> 缓存层】的高可用
![ ](8.webp)
&emsp;&emsp;【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。  
&emsp;&emsp;缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service 对 cache 进行双读或者双写。

![ ](9.webp)
&emsp;&emsp;缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。  
&emsp;&emsp;以 Redis 为例，Redis 天然支持主从同步，Redis 官方也有 sentinel 哨兵机制，来做 Redis 的存活性检测。

![ ](10.webp)
&emsp;&emsp;自动故障转移：当 redis 主挂了的时候，sentinel 能够探测到，会通知调用方访问新的 redis，整个过程由 sentinel 和 redis 集群配合完成，对调用方是透明的。

&emsp;&emsp;说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。  
&emsp;&emsp;这类允许 “cache miss” 的业务场景，缓存架构的建议是：
![ ](11.webp)
&emsp;&emsp;将 kv 缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的 key 水平切分成若干个实例，每个实例的访问并不做高可用。

![ ](12.webp)
&emsp;&emsp;缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回 cache miss，此时缓存挂掉对调用方也是透明的。key 水平切分实例减少，不建议做 re-hash，这样容易引发缓存数据的不一致。

### 【服务层 -> 数据库层】的高可用
&emsp;&emsp;大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。

#### 【服务层 -> 数据库层“读”】的高可用
![ ](13.webp)
&emsp;&emsp;【服务层】到【数据库读】的高可用，是通过读库的冗余来实现的。  
&emsp;&emsp;既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。

![ ](14.webp)
&emsp;&emsp;自动故障转移：当读库挂了的时候，db-connection-pool 能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。

#### 【服务层 -> 数据库层“写”】的高可用
![ ](15.webp)
&emsp;&emsp;【服务层】到【数据库写】的高可用，是通过写库的冗余来实现的。
&emsp;&emsp;以 MySQL 为例，可以设置两个 MySQL 双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是 keepalived 存活探测，相同 virtual IP 提供服务。

![ ](16.webp)
&emsp;&emsp;自动故障转移：当写库挂了的时候，keepalived 能够探测到，会自动的进行故障转移，将流量自动迁移到 shadow-db-master，由于使用的是相同的 virtual IP，这个切换过程对调用方是透明的。

## 五、总结
&emsp;&emsp;高可用 HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。

&emsp;&emsp;方法论上，高可用是通过**冗余+自动故障转移**来实现的。

&emsp;&emsp;整个互联网分层系统架构的高可用，又是通过每一层的冗余+自动故障转移来综合实现的，具体的：  
&emsp;（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是 keepalived + virtual IP 自动故障转移；  
&emsp;（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是 nginx 与 web-server 之间的存活性探测与自动故障转移；  
&emsp;（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过 service-connection-pool 来保证自动故障转移；  
&emsp;（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与 sentinel 保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性；  
&emsp;（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过 db-connection-pool 来保证自动故障转移；  
&emsp;（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是 keepalived + virtual IP 自动故障转移；

---

# 高并发
## 什么是高并发？
&emsp;&emsp;高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，**通过设计保证系统能够同时并行处理很多请求**。

## 高并发相关的常见指标有哪些？
* 响应时间（Response Time）
* 吞吐量（Throughput）
* 每秒查询率 QPS（Query Per Second）
* 并发用户数

### 什么是响应时间？
&emsp;&emsp;系统对请求做出响应的时间。  
&emsp;&emsp;例如：系统处理一个 HTTP 请求需要 200ms，这个 200ms 就是系统的响应时间。

### 什么是吞吐量？
&emsp;&emsp;单位时间内处理的请求数量。

### 什么是 QPS？
&emsp;&emsp;每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。

### 什么是并发用户数？
&emsp;&emsp;同时承载正常使用系统功能的用户数量。  
&emsp;&emsp;例如：一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。

## 如何提升系统的并发能力？
&emsp;&emsp;互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：
&emsp;&emsp;\- 垂直扩展（Scale Up）
&emsp;&emsp;\- 水平扩展（Scale Out）

### 什么是垂直扩展？
&emsp;&emsp;垂直扩展是指，**提升单机处理能力**，垂直扩展的方式又有两种：  
&emsp;（1）**增强单机硬件性能**，例如：增加 CPU 核数如 32 核，升级更好的网卡如万兆，升级更好的硬盘如 SSD，扩充硬盘容量如 2T，扩充系统内存如 128G；  
&emsp;（2）**提升单机架构性能**，例如：使用 Cache 来减少 IO 次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；
> &emsp;&emsp;画外音：在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。

#### 垂直扩展有什么瓶颈？
&emsp;&emsp;不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的**不足**：**单机性能总是有极限的**。

#### 如何突破单机的极限？
&emsp;&emsp;互联网分布式架构设计，高并发终极解决方案还是水平扩展。

### 什么是水平扩展？
&emsp;&emsp;**只要增加服务器数量，就能线性扩充系统性能。**

## 常见的互联网分层架构如何？
![ ](17.webp)

常见互联网分布式架构如上，分为：  
（1）**客户端层**：典型调用方是浏览器 browser 或者手机应用 APP；  
（2）**反向代理层**：系统入口，反向代理；  
（3）**站点应用层**：实现核心应用逻辑，返回 html 或者 json；  
（4）**服务层**：如果实现了服务化，就有这一层；  
（5）**数据-缓存层**：缓存加速访问存储；  
（6）**数据-数据库层**：数据库固化数据存储；

要想真个系统支持水平扩展，就必须每一层都支持水平扩展。

## 各层该如何落地水平扩展？
### 反向代理层如何进行水平扩展？
![ ](18.webp)
&emsp;&emsp;**反向代理层的水平扩展，是通过“DNS 轮询”实现的**：dns-server 对于一个域名配置了多个解析 ip，每次 DNS 解析请求来访问 dns-server，会轮询返回这些 ip。

&emsp;&emsp;当 nginx 成为瓶颈的时候，只要增加服务器数量，新增 nginx 服务的部署，增加一个外网 ip，就能扩展反向代理层的性能，做到理论上的无限高并发。

### 站点层如何进行水平扩展？
![ ](19.webp)
&emsp;&emsp;**站点层的水平扩展，是通过 “nginx” 实现的**，通过修改`nginx.conf`，可以设置多个 web 后端。
> &emsp;&emsp;画外音：nginx 是个例子，有可能是 LVS 或者 F5 等反向代理。

&emsp;&emsp;当 web 后端成为瓶颈的时候，只要增加服务器数量，新增 web 服务的部署，在 nginx 配置中配置上新的 web 后端，就能扩展站点层的性能，做到理论上的无限高并发。

### 服务层如何进行水平扩展？
![ ](20.webp)
&emsp;&emsp;**服务层的水平扩展，是通过“服务连接池”实现的。**

&emsp;&emsp;站点层通过 RPC-client 调用下游的服务层 RPC-server 时，RPC-client 中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在 RPC-client 处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。
> &emsp;&emsp;画外音：如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。

### 数据层如何进行水平扩展？
&emsp;&emsp;在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。

&emsp;&emsp;互联网数据层常见的水平拆分方式有这么几种，以数据库为例：

#### 一、按照范围水平拆分
![ ](21.webp)
每一个数据服务，存储一定范围的数据，上图为例：
* user0 库，存储 uid 范围 1 - 1kw
* user1 库，存储 uid 范围 1kw - 2kw

这个方案的好处是：  
（1）规则简单，service 只需判断一下 uid 范围就能路由到对应的存储服务；  
（2）数据均衡性较好；  
（3）比较容易扩展，可以随时加一个 uid[2kw, 3kw] 的数据服务；

不足是：  
（1）请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大 range 的服务请求压力会更大；

#### 二、按照哈希水平拆分
![ ](22.webp)
每一个数据库，存储某个 key 值 hash 后的部分数据，上图为例：
* user0 库，存储偶数 uid 数据
* user1 库，存储奇数 uid 数据

这个方案的好处是：  
（1）规则简单，service 只需对 uid 进行 hash 能路由到对应的存储服务；  
（2）数据均衡性较好；  
（3）请求均匀性较好；

不足是：  
（1）不容易扩展，扩展一个数据服务，hash 方法改变时候，可能需要进行数据迁移；

## 通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能，有什么本质的不同？
> 画外音：这两个方案千万别搞混。

&emsp;&emsp;通过**水平拆分扩展数据库性能**：  
&emsp;（1）**每个服务器上存储的数据量是总量的 1/n**，所以单机的性能也会有提升；  
&emsp;（2）**n 个服务器上的数据没有交集**，那个服务器上数据的并集是数据的全集；  
&emsp;（3）数据水平拆分到了 n 个服务器上，理论上**读性能扩充了 n 倍，写性能也扩充了 n 倍**（其实远不止 n 倍，因为单机的数据量变为了原来的 1/n）；

&emsp;&emsp;通过**主从同步读写分离扩展数据库性能**：  
&emsp;（1）每个服务器上存储的**数据量是和总量相同**；  
&emsp;（2）**n 个服务器上的数据都一样**，都是全集；  
&emsp;（3）理论上**读性能扩充了 n 倍，写仍然是单点**，写性能不变；
 
&emsp;&emsp;缓存层的水平拆分和数据库层的水平拆分类似，也是以范围拆分和哈希拆分的方式居多，就不再展开。

## 总结
&emsp;&emsp;高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。

&emsp;&emsp;提高系统并发能力的方法主要有两种：
&emsp;&emsp;\- 垂直扩展（Scale Up）
&emsp;&emsp;\- 水平扩展（Scale Out）

&emsp;&emsp;前者垂直扩展可以通过提升单机硬件性能，或者提升单机架构性能，来提高并发性，但单机性能总是有极限的，互联网分布式架构设计高并发终极解决方案还是后者：水平扩展。

&emsp;&emsp;互联网分层架构中，各层次水平扩展的实践又有所不同：  
&emsp;（1）**反向代理层**可以通过“DNS 轮询”的方式来进行水平扩展；  
&emsp;（2）**站点层**可以通过 nginx 来进行水平扩展；  
&emsp;（3）**服务层**可以通过服务连接池来进行水平扩展；  
&emsp;（4）**数据库**可以按照数据范围，或者数据哈希的方式来进行水平扩展；

&emsp;&emsp;各层实施水平扩展后，能够**通过增加服务器数量的方式来提升系统的性能**，做到理论上的性能无限。